######################################################################
#                       PIPELINE DEFINITION
######################################################################
# what modules are we running
run:
     - dataset
    # - run_pairs

######################################################################
#                       verbose module
######################################################################
# verbose config:
# 0: print nothing
# 1: print only upon completing full item
# 2: print everything

verbose: 1
working_dir: '//global/cscratch1/sd/mgatti/clustering_z/Georgios_WZ/'


######################################################################
#                       data set module
######################################################################
# All inputs are read as dictionaries, so it is important to respect the
# identation. It produces the catalog "dataset_path_output", containing
# unknown and reference samples correctly binned for the paircounts.

dataset:

    #****************************************************************
    reference_data:
        path: input_files/specz_COSMOS.fits
        #table: catalog [for hdf5 files]
        file_format: fits
        columns:
            ra_column: RA                           # name of RA column
            dec_column: DEC                         # name of DEC column
            z_column: Z                             # name of Z column
            w_column: None                          # name of W column (not mandatory, could be set to None or erased)


    #****************************************************************
    reference_random:
        path: input_files/specz_COSMOS_random.fits
        file_format: fits
        columns:
            ra_column: RA                         # name of RA column
            dec_column: DEC                       # name of DEC column
            z_column: None                        # name of Z column (not mandatory for randoms, could be set to None or erased)
            w_column: None                        # name of W column (not mandatory for randoms, could be set to None or erased)

    #****************************************************************
    unknown_data:
        path: input_files/photoz_COSMOS_speczrestricted.fits
        file_format: fits
        columns:
            ra_column: RA                           # name of RA column
            dec_column: DEC                         # name of DEC colum
            z_photo_columns: ['Zphoto']             # name of photo Z columns. !! WARNING: the first column has to be the best redshift estimate available (for AC_U_P or AC_U_D_)
            w_column: None                          # name of W column (not mandatory for randoms, could be set to None or erased)


    #****************************************************************
    unknown_random:
        path: input_files/photoz_COSMOS_speczrestricted_random.fits
        file_format: fits
        columns:
            ra_column: RA                           # name of RA column
            dec_column: DEC                         # name of DEC colum
            z_column: None                          # name of photo Z column (not mandatory, could be set to None or erased)
            w_column: None                          # name of W column (not mandatory, could be set to None or erased)


    #****************************************************************
    # Binning in tomographic bins for the unknown
    unknown_bins:
          name_column: Zphoto           #Name of the column for  binning  the unknown in tomobins. It could be different than redshift (e.g. colors)

          #type: between               # if type: between, it creates the array with numpy.linspace. array has to be in the form [min,max,numbofbins].
          #array: [0.4,0.8,3]          # the array will be numpy.linspace(min,max,numbofbins+1,endpoint=True)
                                      # if type: equal, you have to provide the edges of your bins in array (e.g. :array: [0.1,0.2,0.3,0.6,1.0])
                                      #
          type: equal
          array: [0.2,0.43,0.63,0.9]


    reference_bins:                     #Name of the column for binning of the reference. It could be different than redshift
          name_column: Z
          type: between                 # the array will be numpy.linspace(min,max,numbofbins+1,endpoint=True)
          array: [0.2,1.0,8]           # the array will be numpy.linspace(min,max,numbofbins+1,endpoint=True)
                                        # if type: equal, you have to provide the edges of your bins in array (e.g. :array: [0.1,0.2,0.3,0.6,1.0])
          #type: equal
          #array: [0.1,0.2,0.3,0.5,1.0]

    #****************************************************************


    max_objects: 300000000                             # maximum number of
                                                      # objects in catalog
  #  label_every: 10000                                # when assigning bins,
                                                      # set the chunk size
  #  randoms_time: 2.                                  #if randoms are more numerous than randoms_time*len(data_catalog), it cuts them


    kind_regions: 'kmeans'                           # current kinds: 'kmeans' or 'healpix'
    number_of_regions: 20                            # if kind is kmeans, number_of_region is number of regions found by kmeans
                                                     # elif kind is healpix, number_of_region is the healpix nside
    load_regions: None                               # path to the jackknifes centers. Only for kmeans. it can be left to None


    dontsaveplot: True

######################################################################
#                       run pairs module
######################################################################
# commands for calculating paircounts
run_pairs:

    #This module computes the cross-correlation and the autocorrelation for a number of cases.

    corr_tobecomputed: ['CC_P_','AC_R_P_']

    #         possibilities (all of them are as a function of reference redshift, except for AC_U_):
    #                 -   cross correlations:
    #                       -  'CC_A_'    cross correlation in angular scales
    #                       -  'CC_P_'    cross correlation in physical scales
    #                       -  'CC_D_'    cross correlation in physical scales, but with inverse distance weighting
    #
    #
    #                 -   auto correlations:
    #                       -  'AC_U_A_'    auto correlation UNKNOWN SAMPLE in angular scales
    #                       -  'AC_U_P_'    auto correlation UNKNOWN SAMPLE in physical scales
    #                       -  'AC_U_D_'    auto correlation UNKNOWN SAMPLE  in physical scales but with inverse distance weighting
    #                       -  'AC_U_'      1-bin autocorrelation UNKNOWN
    #
    #                       -  'AC_R_A_'    auto correlation REFERENCE SAMPLE in angular scales
    #                       -  'AC_R_P_'    auto correlation REFERENCE SAMPLE in physical scales
    #                       -  'AC_R_D_'    auto correlation REFERENCE  SAMPLE  in physical scales but with inverse distance weighting
    #                       -  'AC_R_R_'    projected 3_D auto correlation REFERENCE  SAMPLE  in physical scales
    #
    #
    #         Schmidt method requires CC_D_ .        bias correction: AC_D_R_ (reference), AC_D_R_ (unknown, only if unknown redshifts are REALLY good)
    #         Menard angular scales method requires CC_A_ .         bias correction: AC_R_A_ (reference), AC_U_A_ (unknown, only if unknown redshifts are REALLY good)
    #         Menard physical scales method requires CC_P_ .         bias correction: AC_R_P_ (reference), AC_U_P_ (unknown, only if unknown redshifts are REALLY good)
    #         Newman method requires CC_P_ , AC_U_ ,AC_R_R_

    tomo_bins: ['1','2','3']     # also 'ALL'

    overwrite: False            # if True, overwrite any existing files

    Nbins: [8]    # number of bins for the AC and CC.

    min_theta: 0.001   #[degrees] min separation for the angular CC and AC
    max_theta: 0.02    #[degrees] max separation for the angular CC and AC

    min_rp: 30.      #[kpc] min separation for the  CC and AC in physical distances
    max_rp: 100.     #[kpc] max separation for the  CC and AC in physical distances

    max_rpar: 80.     # [Mpc] #extrema of the integration for the projected autocorrelation


    cosmology: Planck15           #Accepted cosmology: Planck15,Planck13,WMAP9,WMAP7,WMAP5, FlatLambdaCDM
               ##  [FlatLambdaCDM]                  # For other cosmology modify directly in the dataset module: FlatLambdaCDM(H0=70, Om0=0.3)


    pairs : ['DD','DR']
    w_estimator: 'Natural_noRu'               # estimator for the w(theta) - just for plotting purposes : 'LS','Natural','Hamilton','Natural_noRu','Natural_noRr'
    number_of_cores: 4            # number of cores used in computing the pairs.

    jackknife_ring: False         #   it speeds up the computation when it comes to high number of jackknives.

    dontsaveplot: True
